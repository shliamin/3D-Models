<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Tent Model</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            display: flex;
            flex-wrap: wrap;
            font-family: Arial, sans-serif;
        }
        .content {
            flex: 1;
            padding: 10px;
            min-width: 300px;
        }
        .model {
            flex: 2;
            padding: 10px;
            min-width: 300px;
        }
        .input-group {
            margin-bottom: 10px;
        }
        .surface-area {
            border: 1px solid #000;
            padding: 10px;
            margin-top: 10px;
            display: inline-block;
        }
        .toggle-group {
            margin-top: 10px;
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Interactive Tent Model</h1>
        <div class="input-group">
            <label for="width">Width (cm):</label>
            <input type="number" id="width" value="140" step="1" min="1" onchange="updateModel()">
        </div>
        <div class="input-group">
            <label for="depth">Depth (cm):</label>
            <input type="number" id="depth" value="230" step="1" min="1" onchange="updateModel()">
        </div>
        <div class="input-group">
            <label for="height">Height (cm):</label>
            <input type="number" id="height" value="120" step="1" min="1" onchange="updateModel()">
        </div>
        <div>
            <h2>Mathematical Formula</h2>
            <p>Arc coordinates calculation:</p>
            <p>\[
            x = \text{midX} + (p0_x - \text{midX}) \cdot \cos(\pi \cdot t)
            \]</p>
            <p>\[
            y = \text{midY} + (p0_y - \text{midY}) \cdot \cos(\pi \cdot t)
            \]</p>
            <p>\[
            z = \text{height} \cdot \sin(\pi \cdot t)
            \]</p>
        </div>
        <div class="surface-area">
            <h2>Surface Area</h2>
            <p id="surfaceArea">Surface area: 0 m²</p>
        </div>
        <div class="toggle-group">
            <label><input type="checkbox" id="surface1" checked onchange="updateModel()"> Surface 1</label>
            <label><input type="checkbox" id="surface2" checked onchange="updateModel()"> Surface 2</label>
        </div>
    </div>
    <div class="model" id="tentModel" style="width: 100%; height: 700px;"></div>
    
    <script>
        // Function to create a circular arc
        function circularArc(p0, p1, height, num_points=100) {
            let t = Array.from({length: num_points}, (_, i) => i / (num_points - 1));
            let arc = {x: [], y: [], z: []};
            
            // Midpoint coordinates between p0 and p1
            let midX = (p0[0] + p1[0]) / 2;
            let midY = (p0[1] + p1[1]) / 2;
            
            t.forEach(val => {
                let angle = Math.PI * val;
                
                // Arc coordinates calculation
                let x = midX + (p0[0] - midX) * Math.cos(angle);
                let y = midY + (p0[1] - midY) * Math.cos(angle);
                let z = height * Math.sin(angle);
                
                arc.x.push(x);
                arc.y.push(y);
                arc.z.push(z);
            });
        
            return arc;
        }

        // Function to interpolate between two arcs to create surface points
        function interpolateSurface(arc1, arc2, num_points=100) {
            let surface = {x: [], y: [], z: []};

            for (let i = 0; i < num_points; i++) {
                let xRow = [];
                let yRow = [];
                let zRow = [];
                
                for (let j = 0; j < num_points; j++) {
                    let t = j / (num_points - 1);
                    xRow.push((1 - t) * arc1.x[i] + t * arc2.x[i]);
                    yRow.push((1 - t) * arc1.y[i] + t * arc2.y[i]);
                    zRow.push((1 - t) * arc1.z[i] + t * arc2.z[i]);
                }
                
                surface.x.push(xRow);
                surface.y.push(yRow);
                surface.z.push(zRow);
            }
            
            return surface;
        }

        // Function to calculate the surface area of a surface
        function calculateSurfaceArea(surface, num_points=100) {
            let area = 0;

            for (let i = 0; i < num_points - 1; i++) {
                for (let j = 0; j < num_points - 1; j++) {
                    let x1 = surface.x[i][j];
                    let y1 = surface.y[i][j];
                    let z1 = surface.z[i][j];
                    let x2 = surface.x[i + 1][j];
                    let y2 = surface.y[i + 1][j];
                    let z2 = surface.z[i + 1][j];
                    let x3 = surface.x[i][j + 1];
                    let y3 = surface.y[i][j + 1];
                    let z3 = surface.z[i][j + 1];
                    let x4 = surface.x[i + 1][j + 1];
                    let y4 = surface.y[i + 1][j + 1];
                    let z4 = surface.z[i + 1][j + 1];

                    // Calculate area of two triangles forming a quadrilateral
                    let area1 = 0.5 * Math.sqrt(
                        Math.pow((y2 - y1)*(z3 - z1) - (z2 - z1)*(y3 - y1), 2) +
                        Math.pow((z2 - z1)*(x3 - x1) - (x2 - x1)*(z3 - z1), 2) +
                        Math.pow((x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1), 2)
                    );
                    let area2 = 0.5 * Math.sqrt(
                        Math.pow((y3 - y4)*(z2 - z4) - (z3 - z4)*(y2 - y4), 2) +
                        Math.pow((z3 - z4)*(x2 - x4) - (x3 - x4)*(z2 - z4), 2) +
                        Math.pow((x3 - x4)*(y2 - y4) - (y3 - y4)*(x2 - x4), 2)
                    );

                    area += area1 + area2;
                }
            }

            return area;
        }

        // Function to update the tent model
        function updateModel() {
            // Get values in centimeters and convert to meters
            const width = parseFloat(document.getElementById('width').value) / 100;
            const depth = parseFloat(document.getElementById('depth').value) / 100;
            const height = parseFloat(document.getElementById('height').value) / 100;

            // Tent vertices coordinates
            let vertices = [
                [0, 0, 0],         // Bottom front left corner
                [width, 0, 0],     // Bottom front right corner
                [0, depth, 0],     // Bottom back left corner
                [width, depth, 0], // Bottom back right corner
                [width / 2, depth / 2, height]  // Top center point
            ];

            // Draw arcs intersecting at the tent's top vertex
            let arc1 = circularArc(vertices[0], vertices[3], height);
            let arc2 = circularArc(vertices[1], vertices[2], height);
            let arc3 = circularArc(vertices[3], vertices[0], height);
            let arc4 = circularArc(vertices[2], vertices[1], height);

            // Interpolate to create surface points between arcs
            let surface1 = interpolateSurface(arc1, arc2);
            let surface2a = interpolateSurface(arc3, arc4);

            // Calculate surface areas
            let area1 = calculateSurfaceArea(surface1);
            let area2a = calculateSurfaceArea(surface2a);

            // Initialize total area
            let totalArea = 0;

            // Check which surfaces are enabled
            let data = [];
            if (document.getElementById('surface1').checked) {
                totalArea += area1;
                data.push({
                    x: surface1.x,
                    y: surface1.y,
                    z: surface1.z,
                    type: 'surface',
                    colorscale: [[0, 'rgba(0, 255, 255, 0.3)'], [1, 'rgba(0, 255, 255, 0.3)']],
                    opacity: 0.7,
                    showscale: false
                });
            }
            if (document.getElementById('surface2').checked) {
                totalArea += area2a;
                data.push({
                    x: surface2a.x,
                    y: surface2a.y,
                    z: surface2a.z,
                    type: 'surface',
                    colorscale: [[0, 'rgba(255, 0, 0, 0.3)'], [1, 'rgba(255, 0, 0, 0.3)']],
                    opacity: 0.7,
                    showscale: false
                });
            }

            // Update total surface area
            document.getElementById('surfaceArea').innerText = `Surface area: ${totalArea.toFixed(2)} m²`;

            // Add arcs and edges
            data.push({
                x: arc1.x,
                y: arc1.y,
                z: arc1.z,
                mode: 'lines',
                line: {
                    color: 'blue',
                    width: 5
                },
                type: 'scatter3d'
            });
            data.push({
                x: arc2.x,
                y: arc2.y,
                z: arc2.z,
                mode: 'lines',
                line: {
                    color: 'blue',
                    width: 5
                },
                type: 'scatter3d'
            });
            data.push({
                x: [vertices[0][0], vertices[1][0], vertices[3][0], vertices[2][0], vertices[0][0]],
                y: [vertices[0][1], vertices[1][1], vertices[3][1], vertices[2][1], vertices[0][1]],
                z: [vertices[0][2], vertices[1][2], vertices[3][2], vertices[2][2], vertices[0][2]],
                mode: 'lines',
                line: {
                    color: 'blue',
                    width: 5
                },
                type: 'scatter3d'
            });

            let layout = {
                scene: {
                    xaxis: {
                        title: 'Width',
                        dtick: 0.1  // Grid step for X axis 10 cm
                    },
                    yaxis: {
                        title: 'Depth',
                        dtick: 0.1  // Grid step for Y axis 10 cm
                    },
                    zaxis: {
                        title: 'Height',
                        dtick: 0.1  // Grid step for Z axis 10 cm
                    },
                    aspectratio: {x: width, y: depth, z: height}
                },
                legend: {
                    y: -0.2, 
                    yanchor: 'top' 
                },
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 0
                }
            };

            Plotly.newPlot('tentModel', data, layout);
        }

        // Initialize the model on page load
        updateModel();
    </script>
</body>
</html>
