// polyfill.min.js

// Polyfill for Promise
if (typeof Promise === 'undefined') {
  window.Promise = (function() {
    function Promise(executor) {
      var _this = this;
      this.state = 'pending';
      this.value = undefined;
      this.deferred = [];
      executor(function(x) {
        _this.resolve(x);
      }, function(r) {
        _this.reject(r);
      });
    }
    Promise.prototype.resolve = function(x) {
      var _this = this;
      this.state = 'fulfilled';
      this.value = x;
      this.deferred.forEach(function(deferred) {
        _this.handle(deferred);
      });
    };
    Promise.prototype.reject = function(r) {
      var _this = this;
      this.state = 'rejected';
      this.value = r;
      this.deferred.forEach(function(deferred) {
        _this.handle(deferred);
      });
    };
    Promise.prototype.handle = function(deferred) {
      var _this = this;
      if (this.state === 'pending') {
        this.deferred.push(deferred);
        return;
      }
      setTimeout(function() {
        var cb = _this.state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected;
        if (!cb) {
          ( _this.state === 'fulfilled' ? deferred.resolve : deferred.reject)(_this.value);
          return;
        }
        var ret;
        try {
          ret = cb(_this.value);
        } catch (e) {
          deferred.reject(e);
          return;
        }
        deferred.resolve(ret);
      }, 1);
    };
    Promise.prototype.then = function(onFulfilled, onRejected) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        _this.handle({
          onFulfilled: onFulfilled,
          onRejected: onRejected,
          resolve: resolve,
          reject: reject
        });
      });
    };
    return Promise;
  })();
}

// Polyfill for fetch
if (!self.fetch) {
  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new XMLHttpRequest();
      request.open(init.method || 'GET', input, true);
      for (var i in init.headers) {
        request.setRequestHeader(i, init.headers[i]);
      }
      request.onload = function() {
        resolve({
          ok: true,
          text: function() {
            return Promise.resolve(request.responseText);
          },
          json: function() {
            return Promise.resolve(JSON.parse(request.responseText));
          }
        });
      };
      request.onerror = function() {
        reject(new TypeError('Network request failed'));
      };
      request.send(init.body || null);
    });
  };
}
